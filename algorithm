# í–¥ì—° ì¡°ì§œê¸° ì•Œê³ ë¦¬ì¦˜ v2.0
# ê°œì„ ì‚¬í•­: ë°ì´í„° ëˆ„ì , ìœ ì—°í•œ ì¡° ìˆ˜ ì„¤ì •, ì„±ë¹„ ê· í˜• ê°•í™”, ì„ì›ì§„ ê³ ì •
# ì‚¬ìš©ë²•: íŒŒì¼ ë§¨ ì•„ë˜ì— ìˆëŠ” example()ì„ ì°¸ê³ í•˜ê±°ë‚˜, CSVë¡œ ëª…ë‹¨ì„ ë§Œë“¤ì–´ run()
# Python 3.8+

from collections import defaultdict, Counter
import random
import csv
import math
import json
import os
from copy import deepcopy
from datetime import datetime

random.seed(0)

# ------------ ë°ì´í„° ì €ì¥/ë¡œë“œ ì‹œìŠ¤í…œ ------------
class DataManager:
    def __init__(self, data_file="group_history.json"):
        self.data_file = data_file
        self.history = self.load_history()
    
    def load_history(self):
        """íˆìŠ¤í† ë¦¬ ë°ì´í„°ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤."""
        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return {"groups": [], "people_history": {}}
        return {"groups": [], "people_history": {}}
    
    def save_history(self):
        """íˆìŠ¤í† ë¦¬ ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤."""
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump(self.history, f, ensure_ascii=False, indent=2)
    
    def add_group_result(self, groups, week_num):
        """ì¡° ê²°ê³¼ë¥¼ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€í•©ë‹ˆë‹¤."""
        group_data = {
            "week": week_num,
            "timestamp": datetime.now().isoformat(),
            "groups": []
        }
        
        for group in groups:
            group_info = {
                "id": group['id'],
                "leader": group['leader'].name,
                "members": [m.name for m in group['members']]
            }
            group_data["groups"].append(group_info)
        
        self.history["groups"].append(group_data)
        self.save_history()
    
    def get_previous_groups(self, person_name, weeks_back=2):
        """íŠ¹ì • ì‚¬ëŒì˜ ì´ì „ ì¡° ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        prev_groups = []
        for group_data in self.history["groups"][-weeks_back:]:
            for group in group_data["groups"]:
                if person_name in group["members"]:
                    prev_groups.append(group["members"])
        return prev_groups

# ------------ ìœ í‹¸ / ë°ì´í„° ëª¨ë¸ ------------
class Person:
    def __init__(self, name, gender=None, is_leader=False, prev_week1=None, prev_week2=None, is_veteran=False, data_manager=None):
        self.name = name
        self.gender = gender  # 'M' or 'F' or None
        self.is_leader = is_leader
        self.prev_week1 = set(prev_week1 or [])  # names they sat with week1
        self.prev_week2 = set(prev_week2 or [])
        self.is_veteran = is_veteran
        self.data_manager = data_manager
        
        # ë°ì´í„° ë§¤ë‹ˆì €ê°€ ìˆìœ¼ë©´ íˆìŠ¤í† ë¦¬ì—ì„œ ì´ì „ ì¡° ì •ë³´ë¥¼ ìë™ìœ¼ë¡œ ë¡œë“œ
        if data_manager:
            self.load_history_from_data_manager()

    def load_history_from_data_manager(self):
        """ë°ì´í„° ë§¤ë‹ˆì €ì—ì„œ ì´ì „ ì¡° ì •ë³´ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤."""
        if self.data_manager:
            prev_groups = self.data_manager.get_previous_groups(self.name)
            if len(prev_groups) >= 1:
                self.prev_week1 = set(prev_groups[-1]) - {self.name}
            if len(prev_groups) >= 2:
                self.prev_week2 = set(prev_groups[-2]) - {self.name}

    def __repr__(self):
        flags = []
        if self.is_leader: flags.append("Leader")
        if self.is_veteran: flags.append("Vet")
        return f"{self.name}({self.gender}){'/'.join(flags)}"

# ------------ í˜ë„í‹°(ë¹„ìš©) í•¨ìˆ˜ ì •ì˜ ------------
def penalty_for_placing(person: Person, group, config):
    """
    group: dict with keys: 'members' (list of Person)
    config: dict of penalty weights and target gender ratio
    """
    p = 0.0
    members = group['members']
    names = {m.name for m in members}

    # í•˜ë“œ ì œì•½: 1ì£¼ì°¨(ê°€ì¥ ì˜¤ë˜ëœ ì£¼ì°¨) ê°™ì€ ì¡°ì˜€ë˜ ì‚¬ëŒê³¼ëŠ” ì ˆëŒ€ ê°™ì€ ì¡° ë¶ˆê°€
    # DataManager ë¡œë“œ ìˆœì„œìƒ prev_week2ê°€ 1ì£¼ì°¨, prev_week1ì´ 2ì£¼ì°¨ë¥¼ ì˜ë¯¸
    common_week1 = names & person.prev_week2
    if common_week1:
        return 1e9

    # 1) ìµœê·¼ ì£¼ì°¨(2ì£¼ì°¨) ê°™ì€ ì¡° íšŒí”¼(ê°•í•œ í˜ë„í‹°)
    common_recent = names & person.prev_week1
    if common_recent:
        p += config['w_week1'] * len(common_recent)
    
    # 3) ì¶”ê°€ í˜ë„í‹°: ê°™ì€ ì‚¬ëŒê³¼ ë°˜ë³µì ìœ¼ë¡œ ë§Œë‚˜ëŠ” ê²ƒ ë°©ì§€
    # ì „ì²´ íˆìŠ¤í† ë¦¬ì—ì„œ ë§Œë‚œ ì‚¬ëŒë“¤ê³¼ì˜ ê²¹ì¹¨ì— ëŒ€í•œ í˜ë„í‹°
    if person.data_manager:
        all_previous_partners = set()
        for group_data in person.data_manager.history["groups"]:
            for group in group_data["groups"]:
                if person.name in group["members"]:
                    all_previous_partners.update(group["members"])
        
        # ìê¸° ìì‹  ì œì™¸
        all_previous_partners.discard(person.name)
        
        # í˜„ì¬ ê·¸ë£¹ê³¼ ì´ì „ì— ë§Œë‚œ ì‚¬ëŒë“¤ì˜ ê²¹ì¹¨
        overlap_with_history = names & all_previous_partners
        if overlap_with_history:
            p += config.get('w_history_overlap', 15.0) * len(overlap_with_history)

    # 4) ì—°ì„ì(íŠ¹íˆ í”¼í•¨): ê·¸ë£¹ ë‚´ ë‹¤ë¥¸ ì—°ì„ìê°€ ìˆìœ¼ë©´ í° í˜ë„í‹°
    if person.is_veteran:
        vet_count = sum(1 for m in members if m.is_veteran)
        # if vet_count>0 then adding this person increases vet pairing
        p += config['w_vet'] * vet_count

    # 5) ì„±ë¹„ í˜ë„í‹°: í˜„ì¬ ê·¸ë£¹ ì„±ë¹„ì—ì„œ ë²—ì–´ë‚˜ëŠ” ì •ë„ (ê°œì„ ëœ ì•Œê³ ë¦¬ì¦˜)
    if person.gender in ('M', 'F'):
        # compute gender counts after adding this person
        cnt = Counter(m.gender for m in members if m.gender in ('M','F'))
        cnt[person.gender] += 1
        target_ratio = config.get('target_female_ratio', 0.5)
        
        total_known = cnt['M'] + cnt['F']
        if total_known > 0:
            female_ratio = cnt['F'] / total_known
            # ì„±ë¹„ ë¶ˆê· í˜•ì— ëŒ€í•œ ë” ê°•í•œ í˜ë„í‹°
            ratio_deviation = abs(female_ratio - target_ratio)
            # ê·¸ë£¹ í¬ê¸°ê°€ í´ìˆ˜ë¡ ì„±ë¹„ ë¶ˆê· í˜•ì— ëŒ€í•œ í˜ë„í‹°ë¥¼ ì¦ê°€
            group_size_factor = len(members) + 1
            p += config['w_gender'] * ratio_deviation * group_size_factor * 10
            
            # ê·¹ë‹¨ì ì¸ ì„±ë¹„ ë¶ˆê· í˜•ì— ëŒ€í•œ ì¶”ê°€ í˜ë„í‹°
            if female_ratio < 0.2 or female_ratio > 0.8:
                p += config.get('w_extreme_gender', 20.0)
    else:
        # unknown gender: small uncertainty penalty
        p += config.get('w_unknown_gender', 0.1)

    # 6) size overflow: infinite cost if group full
    capacity = group.get('capacity', 10)  # ê¸°ë³¸ê°’ 10
    if len(members) >= capacity:
        p += 1e6

    return p

# ------------ í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ ------------
def make_groups(people, leaders, num_groups=None, group_capacity=None, config=None, max_iters=2000, data_manager=None):
    """
    people: list of Person (including leaders)
    leaders: list of leader names (must be subset of people)
    num_groups: int (Noneì´ë©´ ìë™ ê³„ì‚°)
    group_capacity: int (Noneì´ë©´ ìë™ ê³„ì‚°)
    config: penalty weights
    data_manager: DataManager ì¸ìŠ¤í„´ìŠ¤
    Returns: list of groups (dicts with 'leader' and 'members')
    """
    
    # ê¸°ë³¸ ì„¤ì •ê°’
    if config is None:
        config = {
            'w_week1': 50.0,   # ë§¤ìš° ê°•í•œ í˜ë„í‹°ë¡œ 1ì£¼ì°¨ ê°™ì€ ì¡° íšŒí”¼
            'w_week2': 8.0,    # 2ì£¼ì°¨ì— ëŒ€í•œ ì‘ì€ í˜ë„í‹°
            'w_history_overlap': 15.0,  # ì „ì²´ íˆìŠ¤í† ë¦¬ ê²¹ì¹¨ ë°©ì§€
            'w_vet': 30.0,     # ì—°ì„ìë“¤ì´ í•¨ê»˜ë˜ëŠ” ê²ƒì„ í”¼í•˜ê¸° ìœ„í•œ ê°•í•œ í˜ë„í‹°
            'w_gender': 6.0,   # ì„±ë¹„ ê· í˜• í˜ë„í‹° ê°€ì¤‘ì¹˜
            'target_female_ratio': 0.5,
            'w_unknown_gender': 0.2,
            'w_extreme_gender': 20.0
        }
    
    # ìë™ìœ¼ë¡œ ì¡° ìˆ˜ì™€ ì¡° í¬ê¸° ê³„ì‚°
    if num_groups is None or group_capacity is None:
        total_people = len(people)
        # 5ì¡° ë˜ëŠ” 6ì¡° ì¤‘ ë” ê· í˜•ì¡íŒ ê²ƒì„ ì„ íƒ
        if num_groups is None:
            candidates = [5, 6]
            best_groups = 5
            min_waste = float('inf')
            for ng in candidates:
                waste = total_people % ng
                if waste < min_waste:
                    min_waste = waste
                    best_groups = ng
            num_groups = best_groups
        
        if group_capacity is None:
            group_capacity = math.ceil(total_people / num_groups)
    
    # ì„ ì œ ì¤‘ë³µ ì œê±°: ì´ë¦„ ê¸°ì¤€ìœ¼ë¡œ unique ì²˜ë¦¬ (ê°€ì¥ ì²˜ìŒ ë“±ì¥ë§Œ ìœ ì§€)
    unique_people = []
    seen_names_initial = set()
    for p in people:
        if p.name not in seen_names_initial:
            unique_people.append(p)
            seen_names_initial.add(p.name)
    people = unique_people

    name_to_person = {p.name: p for p in people}

    # ì„ì›ì§„ ê³ ì • ë°°ì¹˜: ê° ì¡°ì— ì„ì›ì§„ì„ ë¨¼ì € ë°°ì¹˜
    groups = []
    leader_list = [name_to_person[n] for n in leaders if n in name_to_person]
    
    # ì„ì›ì§„ì´ ì¡° ìˆ˜ë³´ë‹¤ ì ìœ¼ë©´ ì¼ë¶€ ì¡°ì— ì„ì›ì§„ ì—†ì´ ì‹œì‘
    if len(leader_list) < num_groups:
        # ì„ì›ì§„ì„ ê°€ëŠ¥í•œ í•œ ê· ë“±í•˜ê²Œ ë¶„ì‚°
        for i in range(num_groups):
            leader = leader_list[i % len(leader_list)] if leader_list else None
            groups.append({'leader': leader, 'members': [leader] if leader else [], 'capacity': group_capacity, 'id': i+1})
    else:
        # ì„ì›ì§„ì´ ì¶©ë¶„í•˜ë©´ ê° ì¡°ì— ì„ì›ì§„ ë°°ì¹˜
        leader_list = leader_list[:num_groups]  # ì¡° ìˆ˜ë§Œí¼ë§Œ ì‚¬ìš©
        for i in range(num_groups):
            leader = leader_list[i]
            groups.append({'leader': leader, 'members': [leader], 'capacity': group_capacity, 'id': i+1})

    # remaining people
    assigned_names = set()
    for g in groups:
        for m in g['members']:
            assigned_names.add(m.name)
    
    remaining = [p for p in people if p.name not in assigned_names]
    
    # (ì´í›„ ë‹¨ê³„ì—ì„  ì‚¬í›„ sanitizeë¡œë„ í•œ ë²ˆ ë” ì•ˆì „ì¥ì¹˜ ì ìš©)

    # sort remaining by "constrainedness" (veterans and people who sat with many others)
    def constrained_score(p):
        return (10 if p.is_veteran else 0) + len(p.prev_week1)*5 + len(p.prev_week2)*2
    remaining.sort(key=constrained_score, reverse=True)

    # Greedy assignment: assign each person to group with minimal penalty
    # ì „ì—­ ì¤‘ë³µ ë°©ì§€: ëª¨ë“  ê·¸ë£¹ì—ì„œ ì´ë¯¸ í• ë‹¹ëœ ì´ë¦„ ì¶”ì 
    all_assigned_names = set()
    for g in groups:
        for m in g['members']:
            all_assigned_names.add(m.name)
    
    for p in remaining:
        # ì´ë¯¸ ë‹¤ë¥¸ ê·¸ë£¹ì— í• ë‹¹ëìœ¼ë©´ ìŠ¤í‚µ
        if p.name in all_assigned_names:
            print(f"ê²½ê³ : {p.name}ì´ ì´ë¯¸ ë‹¤ë¥¸ ì¡°ì— í• ë‹¹ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ìŠ¤í‚µí•©ë‹ˆë‹¤.")
            continue
            
        best_group = None
        best_pen = float('inf')
        # shuffle group order slightly to avoid deterministic ties
        order = list(range(len(groups)))
        random.shuffle(order)
        for j in order:
            g = groups[j]
            # í˜„ì¬ ê·¸ë£¹ì—ë„ ì´ë¯¸ ê°™ì€ ì´ë¦„ì´ ìˆìœ¼ë©´ ìŠ¤í‚µ
            if any(m.name == p.name for m in g['members']):
                continue
            pen = penalty_for_placing(p, g, config)
            if pen < best_pen:
                best_pen = pen
                best_group = g
        if best_group:
            best_group['members'].append(p)
            all_assigned_names.add(p.name)
        else:
            print(f"ê²½ê³ : {p.name}ì„ ë°°ì¹˜í•  ì ì ˆí•œ ì¡°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")

    # Local improvement: try swaps that reduce total penalty
    def total_penalty(groups):
        tot = 0.0
        for g in groups:
            for m in g['members']:
                tot += penalty_for_placing(m, g, config)
        return tot

    def count_overlaps(groups):
        """ì¡° ê°„ì˜ ì¤‘ë³µì„ ê³„ì‚°í•©ë‹ˆë‹¤."""
        overlaps = 0
        for i in range(len(groups)):
            for j in range(i+1, len(groups)):
                names_i = {m.name for m in groups[i]['members']}
                names_j = {m.name for m in groups[j]['members']}
                overlaps += len(names_i & names_j)
        return overlaps

    current_pen = total_penalty(groups)
    improved = True
    it = 0
    
    print(f"ì´ˆê¸° ì¤‘ë³µ ìˆ˜: {count_overlaps(groups)}")
    
    while improved and it < max_iters:
        it += 1
        improved = False
        # try pairwise swaps between groups (excluding leaders)
        for i in range(len(groups)):
            for j in range(i+1, len(groups)):
                gi = groups[i]; gj = groups[j]
                # try all member pairs (skip leader swapping)
                for a_idx, a in enumerate(gi['members']):
                    for b_idx, b in enumerate(gj['members']):
                        if a.is_leader or b.is_leader:
                            continue
                        # ì¤‘ë³µ ì²´í¬: swap í›„ ê°™ì€ ì´ë¦„ì´ ë‘ ê·¸ë£¹ì— ìˆìœ¼ë©´ ì•ˆë¨
                        if a.name == b.name:
                            continue
                        # giì— bì™€ ê°™ì€ ì´ë¦„ì´ ìˆìœ¼ë©´ skip
                        if any(m.name == b.name for m in gi['members']):
                            continue
                        # gjì— aì™€ ê°™ì€ ì´ë¦„ì´ ìˆìœ¼ë©´ skip
                        if any(m.name == a.name for m in gj['members']):
                            continue
                        # try swap a<->b
                        # compute delta penalty quickly by evaluating contributions of a and b only
                        before = penalty_for_placing(a, gi, config) + penalty_for_placing(b, gj, config)
                        # simulate swap
                        gi['members'][a_idx] = b
                        gj['members'][b_idx] = a
                        after = penalty_for_placing(b, gi, config) + penalty_for_placing(a, gj, config)
                        if after < before - 1e-6:
                            current_pen += (after - before)
                            improved = True
                            # keep swap
                        else:
                            # revert
                            gi['members'][a_idx] = a
                            gj['members'][b_idx] = b
                if improved:
                    break
            if improved:
                break
    
    print(f"ìµœì í™” í›„ ì¤‘ë³µ ìˆ˜: {count_overlaps(groups)}")
    print(f"ìµœì í™” ë°˜ë³µ íšŸìˆ˜: {it}")

    # ì‚¬í›„ ì •ë¦¬: ì „ì—­ ì¤‘ë³µ ë° ëˆ„ë½ í•´ê²°
    def sanitize_and_reassign(groups):
        # 1ë‹¨ê³„: ê° ê·¸ë£¹ ë‚´ ì¤‘ë³µ ì œê±° (ì²« ë“±ì¥ë§Œ ìœ ì§€)
        for g in groups:
            seen_local = set()
            unique_members = []
            for m in g['members']:
                if m.name in seen_local:
                    print(f"ê²½ê³ : {m.name}ì´ ì¡° {g['id']} ë‚´ì—ì„œ ì¤‘ë³µë¨ - ì œê±°")
                    continue
                seen_local.add(m.name)
                unique_members.append(m)
            g['members'] = unique_members

        # 2ë‹¨ê³„: ì „ì—­ ì¤‘ë³µ ì²´í¬ ë° ìˆ˜ì •
        # ëª¨ë“  ê·¸ë£¹ì„ ìˆœíšŒí•˜ë©° ê° ì´ë¦„ì´ ì²˜ìŒ ë‚˜íƒ€ë‚˜ëŠ” ê·¸ë£¹ì—ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ” ì œê±°
        name_to_first_group = {}
        for g in groups:
            for m in g['members']:
                if m.name in name_to_first_group:
                    # ì´ë¯¸ ë‹¤ë¥¸ ê·¸ë£¹ì— ìˆìŒ - í˜„ì¬ ê·¸ë£¹ì—ì„œëŠ” ì œê±°
                    continue
                name_to_first_group[m.name] = g

        # ê° ê·¸ë£¹ì—ì„œ ê³ ìœ í•œ ë©¤ë²„ë§Œ ìœ ì§€
        to_reassign = []
        for g in groups:
            unique_members = []
            for m in g['members']:
                if name_to_first_group.get(m.name) is g:
                    unique_members.append(m)
                else:
                    # ë‹¤ë¥¸ ê·¸ë£¹ì—ë„ ìˆëŠ” ê²½ìš° â†’ ì¬ë°°ì¹˜ ëŒ€ìƒ
                    to_reassign.append(m)
            g['members'] = unique_members

        # 3ë‹¨ê³„: ì œê±°ëœ ì¸ì› ì¬ë°°ì¹˜
        reassigned_count = 0
        for p in to_reassign:
            best_group = None
            best_pen = float('inf')
            for g in groups:
                # ìˆ˜ìš© ê°€ëŠ¥ ì—¬ë¶€ ë° ë™ì¼ ì´ë¦„ ì—†ëŠ”ì§€ í™•ì¸
                if len(g['members']) >= g.get('capacity', 10):
                    continue
                if any(m.name == p.name for m in g['members']):
                    continue
                pen = penalty_for_placing(p, g, config)
                if pen < best_pen:
                    best_pen = pen
                    best_group = g
            if best_group is not None:
                best_group['members'].append(p)
                reassigned_count += 1
            else:
                print(f"ê²½ê³ : {p.name}ì„ ì¬ë°°ì¹˜í•  ê·¸ë£¹ì„ ì°¾ì§€ ëª»í•¨")

        if reassigned_count > 0:
            print(f"ì¤‘ë³µ ì¸ì› {reassigned_count}ëª… ì¬ë°°ì¹˜ ì™„ë£Œ")

    sanitize_and_reassign(groups)

    # ì¸ì› ê· í˜•í™”: ì¡°ë³„ ì¸ì›ì´ ìµœëŒ€ 1ëª… ì°¨ì´ ì´ë‚´ê°€ ë˜ë„ë¡ ì¬ë¶„ë°°
    def rebalance_group_sizes(groups):
        total_people = sum(len(g['members']) for g in groups)
        gcount = len(groups)
        base = total_people // gcount
        extra = total_people % gcount
        # ì´ìƒì ì¸ í¬ê¸°: ì•ìª½ extraê°œ ì¡°ëŠ” base+1, ë‚˜ë¨¸ì§€ëŠ” base
        ideal_sizes = {}
        for idx, g in enumerate(groups):
            ideal_sizes[g['id']] = base + 1 if idx < extra else base

        # undersizedì™€ oversized ëª©ë¡ ê³„ì‚°
        def collect():
            unders = []
            overs = []
            for g in groups:
                sz = len(g['members'])
                ideal = ideal_sizes[g['id']]
                if sz < ideal:
                    unders.append((g, ideal - sz))
                elif sz > ideal:
                    overs.append((g, sz - ideal))
            return unders, overs

        changed = True
        while changed:
            changed = False
            unders, overs = collect()
            if not unders or not overs:
                break
            # ê° ë¶€ì¡± ê·¸ë£¹ì— ëŒ€í•´, ì—¬ìœ ê°€ ìˆëŠ” ê·¸ë£¹ì—ì„œ ìµœì ì˜ í•œ ëª…ì„ ì´ë™
            for ug, need in unders:
                if need <= 0:
                    continue
                best_choice = None
                best_delta = float('inf')
                best_from = None
                for og, extra_cnt in overs:
                    if extra_cnt <= 0:
                        continue
                    # ë¦¬ë”ëŠ” ì´ë™í•˜ì§€ ì•ŠìŒ
                    for idx_m, m in enumerate(og['members']):
                        if m.is_leader:
                            continue
                        # ëŒ€ìƒ ê·¸ë£¹ì— ë™ì¼ ì¸ì›ì´ ì´ë¯¸ ìˆìœ¼ë©´ ìŠ¤í‚µ
                        if any(x.name == m.name for x in ug['members']):
                            continue
                        # ì´ë™ ì „/í›„ ë¹„ìš© ê·¼ì‚¬ ë¹„êµ
                        before = penalty_for_placing(m, og, config)
                        after = penalty_for_placing(m, ug, config)
                        delta = after - before
                        if delta < best_delta:
                            best_delta = delta
                            best_choice = (og, idx_m, m)
                            best_from = og
                if best_choice is not None:
                    og, idx_m, m = best_choice
                    # ì‹¤ì œ ì´ë™
                    del og['members'][idx_m]
                    ug['members'].append(m)
                    changed = True
        # ë

    rebalance_group_sizes(groups)

    # ë°ì´í„° ë§¤ë‹ˆì €ê°€ ìˆìœ¼ë©´ ê²°ê³¼ë¥¼ ì €ì¥
    if data_manager:
        week_num = len(data_manager.history["groups"]) + 1
        data_manager.add_group_result(groups, week_num)
    
    return groups, current_pen

# ------------ CSV ì½ê¸° / ì˜ˆì‹œ í¬ë§· ------------
def load_people_from_csv(path, data_manager=None):
    # CSV columns: name,gender,is_leader,prev1_semicolon_separated,prev2_semicolon_separated,is_veteran
    people = []
    with open(path, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            name = row['name'].strip()
            gender = row.get('gender','').strip() or None
            is_leader = row.get('is_leader','').strip().lower() in ('1','true','yes','y')
            prev1 = [s.strip() for s in (row.get('prev1','') or '').split(';') if s.strip()]
            prev2 = [s.strip() for s in (row.get('prev2','') or '').split(';') if s.strip()]
            is_vet = row.get('is_veteran','').strip().lower() in ('1','true','yes','y')
            people.append(Person(name, gender, is_leader, prev1, prev2, is_vet, data_manager))
    
    # ì¤‘ë³µ ì œê±° (ì´ë¦„ ê¸°ì¤€)
    unique_people = []
    seen_names = set()
    for person in people:
        if person.name not in seen_names:
            unique_people.append(person)
            seen_names.add(person.name)
    
    return unique_people

# ------------ ì‚¬ìš©ì ì¹œí™”ì  ì¸í„°í˜ì´ìŠ¤ ------------
def create_groups_from_csv(csv_path, leaders=None, num_groups=None, group_capacity=None, config=None):
    """
    CSV íŒŒì¼ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ ì¡°ë¥¼ ë§Œë“œëŠ” ë©”ì¸ í•¨ìˆ˜
    
    Args:
        csv_path: CSV íŒŒì¼ ê²½ë¡œ
        leaders: ì„ì›ì§„ ì´ë¦„ ë¦¬ìŠ¤íŠ¸ (Noneì´ë©´ CSVì—ì„œ is_leader=Trueì¸ ì‚¬ëŒë“¤ ì‚¬ìš©)
        num_groups: ì¡° ìˆ˜ (Noneì´ë©´ ìë™ ê³„ì‚°)
        group_capacity: ì¡°ë‹¹ ì¸ì›ìˆ˜ (Noneì´ë©´ ìë™ ê³„ì‚°)
        config: í˜ë„í‹° ì„¤ì • (Noneì´ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
    
    Returns:
        groups: ì¡° ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
        penalty: ì´ í˜ë„í‹° ì ìˆ˜
    """
    data_manager = DataManager()
    
    # CSVì—ì„œ ì‚¬ëŒë“¤ ë¡œë“œ
    people = load_people_from_csv(csv_path, data_manager)
    
    # ì„ì›ì§„ ìë™ ê°ì§€
    if leaders is None:
        leaders = [p.name for p in people if p.is_leader]
    
    print(f"ì´ {len(people)}ëª…ì˜ ì‚¬ëŒì„ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.")
    print(f"ì„ì›ì§„: {leaders}")
    
    # ì¡° ìƒì„±
    groups, penalty = make_groups(
        people=people,
        leaders=leaders,
        num_groups=num_groups,
        group_capacity=group_capacity,
        config=config,
        data_manager=data_manager
    )
    
    return groups, penalty, data_manager

def print_groups(groups, show_details=True):
    """ì¡° ê²°ê³¼ë¥¼ ë³´ê¸° ì¢‹ê²Œ ì¶œë ¥í•©ë‹ˆë‹¤."""
    print(f"\n=== ì¡° êµ¬ì„± ê²°ê³¼ ===")
    
    # ê¸°ë³¸ configë¡œ í˜ë„í‹° ê³„ì‚°
    default_config = {
        'w_week1': 50.0, 'w_week2': 8.0, 'w_history_overlap': 15.0, 'w_vet': 30.0, 'w_gender': 6.0,
        'target_female_ratio': 0.5, 'w_unknown_gender': 0.2, 'w_extreme_gender': 20.0
    }
    total_penalty = sum(penalty_for_placing(m, g, default_config) for g in groups for m in g['members'])
    print(f"ì´ í˜ë„í‹°: {total_penalty:.2f}")
    
    for g in groups:
        print(f"\nğŸ“‹ ì¡° {g['id']} - ì¡°ì¥: {g['leader'].name if g['leader'] else 'ì—†ìŒ'}")
        print(f"   ì¸ì›: {len(g['members'])}ëª…")
        
        if show_details:
            print("   êµ¬ì„±ì›:")
            for m in g['members']:
                print(f"     â€¢ {m}")
            
            # ì„±ë¹„ ì •ë³´
            cnt = Counter(m.gender for m in g['members'] if m.gender)
            if cnt:
                total_known = cnt['M'] + cnt['F']
                female_ratio = cnt['F'] / total_known if total_known > 0 else 0
                print(f"   ì„±ë¹„: ë‚¨ì„± {cnt['M']}ëª…, ì—¬ì„± {cnt['F']}ëª… (ì—¬ì„± ë¹„ìœ¨: {female_ratio:.1%})")
            else:
                print("   ì„±ë¹„: ì •ë³´ ì—†ìŒ")

# ------------ ì˜ˆì‹œ ë° ì‹¤í–‰ ------------
def example():
    """ì˜ˆì‹œ ì‹¤í–‰ í•¨ìˆ˜ - í–¥ì—° 34ê¸° ë°ì´í„° ê¸°ë°˜"""
    print("=== í–¥ì—° 34ê¸° ì¡°ì§œê¸° ì•Œê³ ë¦¬ì¦˜ v2.0 ===\n")
    
    # í–¥ì—° 34ê¸° ì„ì›ì§„ (ê³ ì •)
    leaders = ['ì •ë¯¼ì„œ','ì´ìˆ˜ì§„','ìš°í™”ì˜','ì‹ í¬ì˜','ê¹€ì„±ë¯¼']
    
    # í–¥ì—° 34ê¸° ì „ì²´ ëª…ë‹¨
    raw_names = [
        'ê¹€ì˜ˆì›','ë¬¸ì±„ìš´','ê¹€ë¯¼ì„œ','ê¹€ì¤€ì„±','ê¹€ìˆ˜ë¯¼','ê¹€ì¢…ìœ¤',
        'ê¹€ì¬ì¤€','ë¬¸í˜„í¬','ê¹€ì‹œì€','ê¹€ì¤€í˜¸','ë§ˆì„±ìˆ˜','ë…¸ì£¼ì˜',
        'ìœ í•œì›…','ë¬¸í˜•ì¤€','ê¹€ì±„ì›','ì£¼ì•„ì§„','ë°•ì„œì—°','í™ìŠ¹ì•„',
        'ì •ì„¸ì´','ë°•ì„±ì›','ì´ì›ì„­','ìµœì„ ì˜','ì´ì„±í™˜','ìœ¤ìƒ›ë³„',
        'ìµœìœ ì •','ì—¼ê·œë¯¼','í™í•œë¹„','ìµœí˜•ìš°','ìµœì£¼í˜„','ìµœë™í˜¸'
    ]
    
    # ë°ì´í„° ë§¤ë‹ˆì € ì´ˆê¸°í™”
    data_manager = DataManager()
    
    # Person ê°ì²´ ìƒì„± (ì‹¤ì œ ì‚¬ìš©ì‹œì—ëŠ” CSVì—ì„œ ë¡œë“œ)
    people = []
    all_names = leaders + raw_names
    
    # ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ set ì‚¬ìš©
    unique_names = list(set(all_names))
    
    # ì‹¤ì œ ì„±ë³„ ì •ë³´ (í–¥ì—° 34ê¸° ë°ì´í„°)
    gender_map = {
        'ê¹€ë¯¼ì„œ': 'M', 'ê¹€ìˆ˜ë¯¼': 'F', 'ê¹€ì‹œì€': 'F', 'ê¹€ì˜ˆì›': 'F', 'ê¹€ì¬ì¤€': 'M',
        'ê¹€ì¢…ìœ¤': 'M', 'ë…¸ì£¼ì˜': 'F', 'ë¬¸í˜„í¬': 'F', 'ë¬¸í˜•ì¤€': 'M', 'ë°•ì„œì—°': 'F',
        'ë°•ì„±ì›': 'F', 'ì—¼ê·œë¯¼': 'M', 'ìœ í•œì›…': 'M', 'ìœ¤ìƒ›ë³„': 'F', 'ì´ì„±í™˜': 'M',
        'ì´ì›ì„­': 'M', 'ì •ì„¸ì´': 'F', 'ì£¼ì•„ì§„': 'F', 'ìµœë™í˜¸': 'M', 'ìµœì„ ì˜': 'F',
        'ìµœì£¼í˜„': 'F', 'ìµœí˜•ìš°': 'M', 'í™ìŠ¹ì•„': 'F', 'í™í•œë¹„': 'F',
        # ì„ì›ì§„ ì„±ë³„ ì •ë³´ (ì¶”ì •)
        'ì •ë¯¼ì„œ': 'F', 'ì´ìˆ˜ì§„': 'F', 'ìš°í™”ì˜': 'F', 'ì‹ í¬ì˜': 'F', 'ê¹€ì„±ë¯¼': 'M'
    }
    
    # ëˆ„ë½ëœ ì´ë¦„ì— ëŒ€í•´ì„œëŠ” ëœë¤ í• ë‹¹
    for n in unique_names:
        if n not in gender_map:
            gender_map[n] = random.choice(['M','F'])
    
    for n in unique_names:
        # ì„±ë³„ ì •ë³´ (ì‹¤ì œ ë°ì´í„°ë¡œ êµì²´ í•„ìš”)
        gender = gender_map[n]
        is_leader = n in leaders
        is_vet = n in ('ê¹€ì¤€ì„±','ê¹€ì¤€í˜¸','ë§ˆì„±ìˆ˜','ê¹€ì±„ì›','ë¬¸ì±„ìš´','ìµœìœ ì •')
        
        # ì´ì „ ì£¼ì°¨ ì¡° ì •ë³´ (ì‹¤ì œ ë°ì´í„°ë¡œ êµì²´ í•„ìš”)
        # ìê¸° ìì‹ ì„ ì œì™¸í•œ ë‹¤ë¥¸ ì‚¬ëŒë“¤ ì¤‘ì—ì„œ ì„ íƒ
        other_names = [name for name in unique_names if name != n]
        prev1 = random.sample(other_names, k=min(random.randint(0,3), len(other_names))) if not is_leader else []
        prev2 = random.sample(other_names, k=min(random.randint(0,2), len(other_names))) if not is_leader else []
        
        people.append(Person(n, gender, is_leader, prev1, prev2, is_vet, data_manager))

    # ê°œì„ ëœ ì„¤ì •ê°’
    config = {
        'w_week1': 50.0,   # 1ì£¼ì°¨ ê°™ì€ ì¡° íšŒí”¼ (ìµœìš°ì„ )
        'w_week2': 8.0,    # 2ì£¼ì°¨ ê°™ì€ ì¡° íšŒí”¼
        'w_history_overlap': 15.0,  # ì „ì²´ íˆìŠ¤í† ë¦¬ ê²¹ì¹¨ ë°©ì§€
        'w_vet': 30.0,     # ì—°ì„ì ë¶„ì‚°
        'w_gender': 6.0,   # ì„±ë¹„ ê· í˜•
        'target_female_ratio': 0.5,
        'w_unknown_gender': 0.2,
        'w_extreme_gender': 20.0  # ê·¹ë‹¨ì  ì„±ë¹„ ë¶ˆê· í˜• ë°©ì§€
    }

    print(f"ì´ {len(people)}ëª…ìœ¼ë¡œ ì¡°ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.")
    print(f"ì„ì›ì§„: {leaders}")
    print(f"ìë™ìœ¼ë¡œ ì¡° ìˆ˜ì™€ ì¡° í¬ê¸°ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.\n")

    # ì¡° ìƒì„± (ìë™ ê³„ì‚° ëª¨ë“œ)
    groups, penalty = make_groups(
        people=people, 
        leaders=leaders, 
        num_groups=None,  # ìë™ ê³„ì‚°
        group_capacity=None,  # ìë™ ê³„ì‚°
        config=config,
        data_manager=data_manager
    )
    
    # ê²°ê³¼ ì¶œë ¥
    print_groups(groups, show_details=True)
    
    print(f"\n=== ì‚¬ìš©ë²• ì•ˆë‚´ ===")
    print("1. CSV íŒŒì¼ë¡œ ì‹¤ì œ ë°ì´í„°ë¥¼ ì…ë ¥í•˜ë ¤ë©´:")
    print("   groups, penalty, dm = create_groups_from_csv('members.csv')")
    print("2. ì¡° ìˆ˜ë¥¼ ì§ì ‘ ì§€ì •í•˜ë ¤ë©´:")
    print("   groups, penalty, dm = create_groups_from_csv('members.csv', num_groups=6)")
    print("3. íˆìŠ¤í† ë¦¬ëŠ” 'group_history.json' íŒŒì¼ì— ìë™ ì €ì¥ë©ë‹ˆë‹¤.")

def create_sample_csv():
    """ìƒ˜í”Œ CSV íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤."""
    sample_data = [
        ['name', 'gender', 'is_leader', 'prev1', 'prev2', 'is_veteran'],
        ['ì •ë¯¼ì„œ', 'F', 'True', '', '', 'False'],
        ['ì´ìˆ˜ì§„', 'F', 'True', '', '', 'False'],
        ['ìš°í™”ì˜', 'F', 'True', '', '', 'False'],
        ['ì‹ í¬ì˜', 'F', 'True', '', '', 'False'],
        ['ê¹€ì„±ë¯¼', 'M', 'True', '', '', 'False'],
        ['ê¹€ì˜ˆì›', 'F', 'False', 'ê¹€ë¯¼ì„œ;ê¹€ìˆ˜ë¯¼', 'ê¹€ì¬ì¤€', 'False'],
        ['ë¬¸ì±„ìš´', 'F', 'False', 'ê¹€ì¤€ì„±', 'ë¬¸í˜„í¬', 'True'],
        ['ê¹€ë¯¼ì„œ', 'F', 'False', 'ê¹€ì˜ˆì›;ê¹€ìˆ˜ë¯¼', 'ê¹€ì‹œì€', 'False'],
        ['ê¹€ì¤€ì„±', 'M', 'False', 'ë¬¸ì±„ìš´', 'ê¹€ì¤€í˜¸', 'True'],
        ['ê¹€ìˆ˜ë¯¼', 'M', 'False', 'ê¹€ì˜ˆì›;ê¹€ë¯¼ì„œ', 'ë§ˆì„±ìˆ˜', 'False'],
    ]
    
    with open('sample_members.csv', 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerows(sample_data)
    
    print("ìƒ˜í”Œ CSV íŒŒì¼ 'sample_members.csv'ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.")

if __name__ == '__main__':
    # ì˜ˆì‹œ ì‹¤í–‰ (CSV íŒŒì¼ì´ ì—†ì„ ë•Œë§Œ)
    if not os.path.exists('hyangyeon_34.csv'):
        example()
        # ìƒ˜í”Œ CSV ìƒì„±
        print("\n" + "="*50)
        create_sample_csv()
    else:
        print("ì‹¤ì œ ë°ì´í„° íŒŒì¼ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤. CSV íŒŒì¼ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        groups, penalty, dm = create_groups_from_csv('hyangyeon_34.csv')
        print_groups(groups, show_details=True)
